 Features Implemented:
‚úÖ Users see online/offline community members
‚úÖ Users can initiate a chat
‚úÖ Prevents duplicate conversations
‚úÖ Messages are sent and received in real-time
‚úÖ Shows typing indicator & unread messages
‚úÖ Supabase listens for new messages

üìå 1Ô∏è‚É£ Fetching Community Users
üìù Description
Fetch all users (online & offline)
Sort by online first
Allow filtering (e.g., same language learners)
üîó Supabase Database:
users table: id, username, profile_picture, native_language, learning_language, is_online, last_active
conversations table: id, user1_id, user2_id, created_at, updated_at
messages table: id, conversation_id, sender_id, content, created_at, is_read
üîç Fetch Users in Community (Community.js)
javascript
Copy
Edit
import React, { useEffect, useState } from 'react';
import { supabase } from '../lib/supabaseClient';
import { useNavigate } from 'react-router-dom';
import { Button } from './ui/button';
import UserProfileCard from './UserProfileCard';

const Community = () => {
  const [users, setUsers] = useState([]);
  const navigate = useNavigate();

  useEffect(() => {
    fetchUsers();
  }, []);

  const fetchUsers = async () => {
    const { data, error } = await supabase
      .from('users')
      .select('*')
      .order('is_online', { ascending: false });

    if (error) {
      console.error('Error fetching users:', error);
    } else {
      setUsers(data);
    }
  };

  const startChat = async (userId) => {
    navigate(`/chat/${userId}`);
  };

  return (
    <div className="py-8">
      <h2 className="text-2xl font-bold mb-6 text-center">Community</h2>
      <div className="grid gap-4 md:grid-cols-2 lg:grid-cols-3 max-w-6xl mx-auto px-4">
        {users.map(user => (
          <UserProfileCard 
            key={user.id} 
            user={user} 
            onClick={() => startChat(user.id)} 
          />
        ))}
      </div>
    </div>
  );
};

export default Community;
üìå 2Ô∏è‚É£ Initiating a Chat (Start Conversation)
üìù Description
When a user clicks "Start Chat," check if a conversation exists
If it exists, redirect to chat
If not, create a new conversation
üõ†Ô∏è Start Chat Function
javascript
Copy
Edit
const startChat = async (userId) => {
  const { data: currentUser } = await supabase.auth.getUser();
  if (!currentUser?.user?.id) {
    navigate('/login');
    return;
  }

  const currentUserId = currentUser.user.id;

  // Check if conversation exists
  const { data: existingConv } = await supabase
    .from('conversations')
    .select('id')
    .or(`(user1_id.eq.${currentUserId},user2_id.eq.${userId})`)
    .or(`(user1_id.eq.${userId},user2_id.eq.${currentUserId})`)
    .maybeSingle();

  if (existingConv) {
    navigate(`/chat/${existingConv.id}`);
    return;
  }

  // Create new conversation
  const { data: newConversation } = await supabase
    .from('conversations')
    .insert([{ user1_id: currentUserId, user2_id: userId }])
    .select('id')
    .single();

  navigate(`/chat/${newConversation.id}`);
};
üìå 3Ô∏è‚É£ Chat Page - Sending & Receiving Messages in Real-Time
üìù Description
Fetch previous messages
Subscribe to new messages (real-time updates)
Send new messages
Mark messages as read
üìå Chat Component (Chat.js)
javascript
Copy
Edit
import React, { useEffect, useState } from 'react';
import { supabase } from '../lib/supabaseClient';
import { useParams } from 'react-router-dom';

const Chat = () => {
  const { conversationId } = useParams();
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');

  useEffect(() => {
    fetchMessages();
    
    const subscription = supabase
      .channel('messages')
      .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'messages' }, (payload) => {
        setMessages((prev) => [...prev, payload.new]);
      })
      .subscribe();

    return () => {
      supabase.removeChannel(subscription);
    };
  }, []);

  const fetchMessages = async () => {
    const { data } = await supabase
      .from('messages')
      .select('*')
      .eq('conversation_id', conversationId)
      .order('created_at', { ascending: true });

    setMessages(data || []);
  };

  const sendMessage = async () => {
    if (!newMessage.trim()) return;

    const { data: currentUser } = await supabase.auth.getUser();
    const senderId = currentUser?.user?.id;

    await supabase
      .from('messages')
      .insert([{ conversation_id: conversationId, sender_id: senderId, content: newMessage }]);

    setNewMessage('');
  };

  return (
    <div>
      <div className="chat-window">
        {messages.map(msg => (
          <div key={msg.id} className={`message ${msg.sender_id === senderId ? 'sent' : 'received'}`}>
            {msg.content}
          </div>
        ))}
      </div>
      <input 
        value={newMessage} 
        onChange={(e) => setNewMessage(e.target.value)} 
        placeholder="Type a message..." 
      />
      <button onClick={sendMessage}>Send</button>
    </div>
  );
};

export default Chat;
üìå 4Ô∏è‚É£ Supabase Database Schema
sql
Copy
Edit
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  username TEXT NOT NULL,
  profile_picture TEXT,
  native_language TEXT,
  learning_language TEXT,
  is_online BOOLEAN DEFAULT false,
  last_active TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user1_id UUID REFERENCES users(id) ON DELETE CASCADE,
  user2_id UUID REFERENCES users(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID REFERENCES conversations(id) ON DELETE CASCADE,
  sender_id UUID REFERENCES users(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  created_at TIMESTAMPTZ DEFAULT now(),
  is_read BOOLEAN DEFAULT false
);
üîó Final Steps
‚úÖ Test User Fetching - Ensure community page loads users
‚úÖ Test Chat Creation - Start a conversation
‚úÖ Test Real-time Messaging - Send messages and check updates
‚úÖ Check Supabase Policies - Ensure users can read/write only their own data